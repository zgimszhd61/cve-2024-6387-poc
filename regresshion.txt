## Qualys 安全公告

### OpenSSH 服务器中的远程代码执行漏洞（CVE-2024-6387）

### 内容

#### 概述
在基于 glibc 的 Linux 系统上，OpenSSH 服务器存在一个远程代码执行漏洞。

#### 详细信息
1. **SSH-2.0-OpenSSH_3.4p1 Debian 1:3.4p1-1.woody.3（Debian 3.0r6，2005年发布）**
   - 理论
   - 实践
   - 时间

2. **SSH-2.0-OpenSSH_4.2p1 Debian-7ubuntu3（Ubuntu 6.06.1，2006年发布）**
   - 理论，第一部分
   - 理论，第二部分
   - 实践
   - 时间

3. **SSH-2.0-OpenSSH_9.2p1 Debian-2+deb12u2（Debian 12.5.0，2024年发布）**
   - 理论
   - 实践
   - 时间

#### 其他内容
- 针对 amd64 的漏洞利用
- 补丁和缓解措施
- 致谢
- 时间线
- 外部系统分析：无需搜索

OpenSSH 是世界上最安全的软件之一，但我们发现其服务器（sshd）存在一个漏洞（信号处理器竞争条件）。如果客户端在指定时间内未认证，sshd 的 SIGALRM 处理器会异步调用一些不安全的函数（如 syslog()），导致漏洞。这一漏洞在默认配置下影响 sshd。

我们发现这个漏洞实际上是 CVE-2006-5051 的回归，该漏洞在 2006 年被报告。这个回归是在 2020 年 10 月（OpenSSH 8.5p1）引入的，因一次代码提交意外移除了 sigdie() 函数中的一个安全保护。

不同版本的 OpenSSH 受影响情况如下：
- OpenSSH < 4.4p1：如果未打 CVE-2006-5051 补丁，存在漏洞。
- 4.4p1 <= OpenSSH < 8.5p1：没有漏洞。
- 8.5p1 <= OpenSSH < 9.8p1：再次存在漏洞。

这个漏洞在基于 glibc 的 Linux 系统上可以被远程利用，导致未认证的远程代码执行。我们参考了一篇 2001 年的论文来尝试利用这个漏洞。

为了验证，我们首先在旧版本的 OpenSSH 上进行实验，然后再尝试在新版本上利用这个漏洞。实验结果显示，利用这个漏洞需要多次尝试才能成功获得远程 root 权限。

这项研究仍在进行中：

- 我们只针对虚拟机，而不是裸机服务器，网络连接大致稳定（~10ms的包抖动）；
- 我们相信我们的漏洞利用可以大大改进；
- 我们开始研究amd64漏洞利用，这更困难，因为ASLR更强。

在我们开始研究amd64几天后，我们注意到OpenSSH的Bugzilla上有一个关于sshd的SIGALRM处理程序死锁的错误报告：

  https://bugzilla.mindrot.org/show_bug.cgi?id=3690

因此，我们决定立即联系OpenSSH的开发人员（让他们知道这个死锁是由一个可利用的漏洞引起的），我们暂停了amd64的工作，并开始编写这个建议。

========================================================================
SSH-2.0-OpenSSH_3.4p1 Debian 1:3.4p1-1.woody.3 (Debian 3.0r6, 2005年)
========================================================================

------------------------------------------------------------------------
理论
------------------------------------------------------------------------

    但这不像我，我正在突破
        -- The Interrupters, "Haven't Seen the Last of Me"

这个OpenSSH版本的SIGALRM处理程序调用packet_close()，它调用buffer_free()，进而调用xfree()和free()，而free()不是异步信号安全的：

------------------------------------------------------------------------
 302 grace_alarm_handler(int sig)
 303 {
 ...
 307         packet_close();
------------------------------------------------------------------------
 329 packet_close(void)
 330 {
 ...
 341         buffer_free(&input);
 342         buffer_free(&output);
 343         buffer_free(&outgoing_packet);
 344         buffer_free(&incoming_packet);
------------------------------------------------------------------------
 35 buffer_free(Buffer *buffer)
 36 {
 37         memset(buffer->buf, 0, buffer->alloc);
 38         xfree(buffer->buf);
 39 }
------------------------------------------------------------------------
 51 xfree(void *ptr)
 52 {
 53         if (ptr == NULL)
 54                 fatal("xfree: NULL pointer given as argument");
 55         free(ptr);
 56 }
------------------------------------------------------------------------

因此，我们开始阅读这个Debian glibc（2.2.5）的malloc代码，看看第一次调用free()是否会被SIGALRM中断，并在SIGALRM处理程序内的第二次调用free()时利用（如上面的第341-344行）。由于这个glibc的malloc没有针对Solar Designer在2000年开创的unlink()技术进行加固，我们很快发现了chunk_free()中的一个有趣代码路径（这是free()内部调用的）。

#### 结构体定义

```c
struct malloc_chunk {
  INTERNAL_SIZE_T prev_size; // 前一个块的大小（如果空闲）。
  INTERNAL_SIZE_T size;      // 当前块的大小（包括开销）。
  struct malloc_chunk* fd;   // 前向指针（仅在空闲时使用）。
  struct malloc_chunk* bk;   // 后向指针。
};
```

#### 宏定义

```c
#define unlink(P, BK, FD) \
{ \
  BK = P->bk; \
  FD = P->fd; \
  FD->bk = BK; \
  BK->fd = FD; \
}
```

#### 函数片段

```c
chunk_free(arena *ar_ptr, mchunkptr p) {
  INTERNAL_SIZE_T hd = p->size; // 获取当前块的大小
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);

  if (!(inuse_bit_at_offset(next, nextsz))) { // 如果下一个块未使用
    unlink(next, bck, fwd); // 解除链接
  } else {
    set_head(next, nextsz); // 清除使用标志
  }

  frontlink(ar_ptr, p, sz, idx, bck, fwd);
}
```

#### 利用过程

1. **内存布局**：
   ```
   ... |p|s|f|b|  chunk_X  |p|s|f|b|  chunk_Y  |p|s|f|b|  chunk_Z  | ...
   ```

2. **步骤**：
   - 如果在 `free(chunk_Y)` 调用时被 `SIGALRM` 中断，且中断发生在第3246行之后但在第3251行之前，那么 `chunk_Y` 已被标记为空闲，但还未加入双向链表。
   - 如果在 `SIGALRM` 处理程序中 `packet_close()` 调用了 `free(chunk_X)`，代码会进入第3230-3244行，因为 `chunk_Y` 被标记为空闲，并且 `chunk_Y` 会在第3241行被解除链接。
   - 由于 `chunk_Y` 的 `fd` 和 `bk` 指针仍然包含用户数据，可以利用这种情况覆盖 `glibc` 的 `__free_hook` 函数指针，从而在下一次调用 `free()` 时执行远程代码。

#### 参考链接

- [unlink() 技术和 aa4bmo 原语](https://www.openwall.com/articles/JPEG-COM-Marker-Vulnerability#exploit)
- [Phrack 文章](http://phrack.org/issues/61/6.html#article)

通过这种方式，可以在没有 ASLR 和 NX 的旧 Debian 版本中实现远程代码执行。
## 简化描述

### 攻击方法

为了攻击 `sshd`，我们在 `sshd` 解析 DSA 公钥时中断 `free()` 调用（即第 144 行的 `free(chunk_Y)`），并在 `packet_close()` 的 `free()` 调用中利用它（即第 341-344 行的 `free(chunk_X)`）。

```c
136 buffer_get_bignum2(Buffer *buffer, BIGNUM *value)
137 {
138     u_int len;
139     u_char *bin = buffer_get_string(buffer, &len);
...
143     BN_bin2bn(bin, len, value);
144     xfree(bin);
145 }
```

起初，我们无法在正确的时间中断第 144 行的 `free()` 调用。后来，我们发现可以通过以下方法提高成功率：DSA 公钥解析代码允许我们调用 `free()` 四次（第 704-707 行），而 `sshd` 允许我们尝试六次用户认证（AUTH_FAIL_MAX）；如果这 24 次 `free()` 调用中的任何一次在正确的时间被中断，我们就能在 SIGALRM 处理程序中实现远程代码执行。

```c
678 key_from_blob(u_char *blob, int blen)
679 {
...
693     switch (type) {
...
702     case KEY_DSA:
703         key = key_new(type);
704         buffer_get_bignum2(&b, key->dsa->p);
705         buffer_get_bignum2(&b, key->dsa->q);
706         buffer_get_bignum2(&b, key->dsa->g);
707         buffer_get_bignum2(&b, key->dsa->pub_key);
```

通过这种改进，我们在大约一个月后终于成功了。

### 时间策略

我们实施了以下三重时间策略：

1. 提前发送几乎完整的 DSA 公钥包，只留最后一个字节在最后一刻发送，以减少网络延迟的影响。同时禁用 Nagle 算法。
2. 记录中位往返时间（通过定期发送数据包并接收 `sshd` 的响应），并记录我们预期连接被 `sshd` 关闭的时间与实际关闭时间之间的差异，调整我们发送最后一个字节的时间。
3. 这些时间差异帮助我们跟踪时钟偏差和网络延迟，显示出随时间变化的可预测模式。最终，我们发现重复使用最近的测量结果效果最好。可能深度学习会带来更好的结果，这留给有兴趣的读者去探索。

我们通过从 `sshd` 获取非自愿反馈，慢慢调整我们的时间，以增加赢得竞争条件的机会：

- 如果我们收到 `DSA` 公钥包的响应（`SSH2_MSG_USERAUTH_FAILURE`），说明我们发送得太早了。
- 如果我们无法发送 `DSA` 包的最后一个字节，说明我们等待得太久了。
- 如果我们能发送 `DSA` 包的最后一个字节，但在 `sshd` 关闭连接前没有收到响应，说明我们的时间是准确的。

这种反馈帮助我们瞄准一个较大的竞争窗口，虽然命中这个窗口并不保证成功，但在这个大窗口内有24个小窗口，命中这些小窗口可以保证成功。

通过这些改进，平均需要尝试约10,000次才能赢得这个竞争条件，即每600秒接受10个连接，大约需要一周时间获得远程 root shell。

### 理论

OpenSSH 这个版本的 `SIGALRM` 处理程序不再调用 `packet_close()`，而且这个 Ubuntu 的 `glibc` 总是会在进入 `malloc` 系列函数时获取一个强制锁，防止我们在调用这些函数时中断并在另一次调用中利用它们。我们需要找到其他解决方案。

CVE-2006-5051 提到 `GSSAPI` 中的双重释放漏洞，但 `GSSAPI` 默认未启用。另一方面，`PAM` 默认启用，并且 `pam_end()` 由 `sshd` 的 `SIGALRM` 处理程序调用。我们找到了 `pam_set_data()`，如果在合适的时间被 `SIGALRM` 中断，会使 `PAM` 的内部结构处于不一致状态，在 `SIGALRM` 处理程序中的 `pam_end()` 调用时可以被利用。
## 简单描述

### pam_set_data 函数

```c
33 int pam_set_data(
34     pam_handle_t *pamh,
..
37     void (*cleanup)(pam_handle_t *pamh, void *data, int error_status))
38 {
39     struct pam_data *data_entry;
..
57     } else if ((data_entry = malloc(sizeof(*data_entry)))) {
..
65         data_entry->next = pamh->data;
66         pamh->data = data_entry;
..
74     data_entry->cleanup = cleanup;
```

### 问题描述

如果 pam_set_data 函数在执行到第66行之后、第74行之前被 SIGALRM 信号中断，data_entry 已经链接到 PAM 的结构中，但 cleanup 字段（函数指针）还没有初始化。如果我们能控制 cleanup（通过之前堆分配的残留），当 pam_end() 调用 _pam_free_data() 时，可以执行任意代码。

```c
104 void _pam_free_data(pam_handle_t *pamh, int status)
105 {
106     struct pam_data *last;
107     struct pam_data *data;
...
112     data = pamh->data;
113 
114     while (data) {
115         last = data;
116         data = data->next;
117         if (last->cleanup) {
118             last->cleanup(pamh, last->data, status);
```

### 解决方案

然而，pam_set_data() 只能从 PAM 模块调用，如果被 SIGALRM 中断，pamh->caller_is 仍然是 _PAM_CALLED_FROM_MODULE，此时 pam_end() 会立即返回，不会调用 _pam_free_data()。

### 第二种理论

我们发现 sshd 在第601行将指向全局 sshpam_handle 指针的指针传递给 pam_start()。如果 pam_start() 被 SIGALRM 中断，可能会使 sshpam_handle 指向的结构处于不一致状态，从而在 SIGALRM 处理程序中调用 "pam_end(sshpam_handle, sshpam_err)" 时被利用。

```c
202 static pam_handle_t *sshpam_handle = NULL;
...
584 sshpam_init(Authctxt *authctxt)
585 {
...
600         sshpam_err =
601             pam_start(SSHD_PAM_SERVICE, user, &store_conv, &sshpam_handle);
```

------------------------------------------------------------------------
 18 int pam_start (
 ..
 22     pam_handle_t **pamh)
 23 {
 ..
 32     if ((*pamh = calloc(1, sizeof(**pamh))) == NULL) {
...
110     if ( _pam_init_handlers(*pamh) != PAM_SUCCESS ) {
------------------------------------------------------------------------
 319 int _pam_init_handlers(pam_handle_t *pamh)
 320 {
 ...
 398                 retval = _pam_parse_conf_file(pamh, f, pamh->service_name, PAM_T_ANY
------------------------------------------------------------------------
  66 static int _pam_parse_conf_file(pam_handle_t *pamh, FILE *f
  ..
  73 {
 ...
 252             res = _pam_add_handler(pamh, must_fail, other
------------------------------------------------------------------------
 581 int _pam_add_handler(pam_handle_t *pamh
 ...
 585 {
 ...
 755     the_handlers = (other) ? &pamh->handlers.other : &pamh->handlers.conf;
 ...
 767         handler_p = &the_handlers->authenticate;
 ...
 874     if ((*handler_p = malloc(sizeof(struct handler))) == NULL) {
 ...
 886     (*handler_p)->next = NULL;
------------------------------------------------------------------------

在第32行，`pam_start()`函数立即将`sshd`的`sshpam_handle`设置为一个通过`calloc()`分配的内存块；这是安全的，因为`calloc()`会将这块内存初始化为零。另一方面，如果`_pam_add_handler()`函数（`pam_start()`会多次调用它）在第874行之后但在第886行之前被`SIGALRM`信号中断，那么一个通过`malloc()`分配的结构体会被链接到`pamh`中，但它的`next`字段还没有初始化。如果我们能够控制`next`（通过之前堆分配的剩余部分），那么在调用`pam_end()`（在`SIGALRM`处理程序内部）时，我们可以传递一个任意指针给`free()`，这发生在下面的第1020行（和第1017行）。

------------------------------------------------------------------------
 11 int pam_end(pam_handle_t *pamh, int pam_status)
 12 {
 ..
 31     if ((ret = _pam_free_handlers(pamh)) != PAM_SUCCESS) {
------------------------------------------------------------------------
 925 int _pam_free_handlers(pam_handle_t *pamh)
 926 {
 ...
 954     _pam_free_handlers_aux(&(pamh->handlers.conf.authenticate));
------------------------------------------------------------------------
1009 void _pam_free_handlers_aux(struct handler **hp)
1010 {
1011     struct handler *h = *hp;
1012     struct handler *last;
....
1015     while (h) {
1016         last = h;
1017         _pam_drop(h->argv);  /* This is all alocated in a single chunk */
1018         h = h->next;
1019         memset(last, 0, sizeof(*last));
1020         free(last);
1021     }
------------------------------------------------------------------------

我们因为这个Ubuntu的glibc已经对旧的unlink()技术进行了加固，所以决定将任意的free()转换为Malloc Maleficarum的House of Mind（fastbin版本）：我们释放自己非主线程的内存块，将伪造的arena指向sshd的.got.plt（这个Ubuntu的sshd有ASLR但没有PIE），并用堆中的shellcode地址覆盖_exit()的入口（这个Ubuntu的堆默认是可执行的）。更多关于Malloc Maleficarum的信息，请参见：

https://seclists.org/bugtraq/2005/Oct/118

## 攻击过程

### 问题一：数据存储位置
我们需要将伪造的内存区域指针存储在堆内存的0x08100000地址，但我们只能控制用户名。幸运的是，一个长度约128KB的用户名可以让我们将数据存储在这个高地址。

### 问题二：大小字段
伪造的内存块大小字段不能太大，否则会被free()函数的安全检查拒绝。由于用户名是以空字符结尾的字符串，不能包含空字节，但_pam_free_handlers_aux()函数会将其释放的结构体清零，因此我们可以利用这一点来修改伪造块的大小字段，再进行释放。

### 问题三：多次释放
在释放伪造的内存块之前，我们需要应对多次free()调用。我们通过将这些free()指向伪造的IS_MMAPPED块来使其无效，因为这些块的munmap()调用会失败，从而成为无操作。

最终，我们的长用户名还可以控制20个不同结构体的未初始化next字段，因为pam_start()多次调用_pam_add_handler()，这使得我们有更大的操作窗口。

## 时间策略

### 重用策略
我们对Ubuntu 6.06.1的攻击策略与对Debian 3.0r6的相同：平均需要尝试约10,000次才能成功，并且每120秒接受10个连接，大约需要1-2天才能获得远程root权限。

注意：由于这个Ubuntu版本的glibc在进入malloc系列函数时总是获取锁，不幸的攻击者可能会在获得root权限前导致所有连接死锁。我们没有尝试解决这个问题，因为我们的最终目标是攻击一个现代的OpenSSH版本。



========================================================================
SSH-2.0-OpenSSH_9.2p1 Debian-2+deb12u2 (Debian 12.5.0, from 2024)
========================================================================

------------------------------------------------------------------------
Theory
------------------------------------------------------------------------

    Now you're ready, take the demons head on
        -- The Interrupters, "Be Gone"

The SIGALRM handler of this OpenSSH version does not call packet_close()
nor pam_end(); in fact it calls only one interesting function, syslog():

------------------------------------------------------------------------
 358 grace_alarm_handler(int sig)
 359 {
 ...
 370         sigdie("Timeout before authentication for %s port %d",
 371             ssh_remote_ipaddr(the_active_state),
 372             ssh_remote_port(the_active_state));
------------------------------------------------------------------------
 96 #define sigdie(...)             sshsigdie(__FILE__, __func__, __LINE__, 0, SYSLOG_LEVEL_ERROR, NULL, __VA_ARGS__)
------------------------------------------------------------------------
451 sshsigdie(const char *file, const char *func, int line, int showfunc,
452     LogLevel level, const char *suffix, const char *fmt, ...)
453 {
...
457         sshlogv(file, func, line, showfunc, SYSLOG_LEVEL_FATAL,
458             suffix, fmt, args);
------------------------------------------------------------------------
464 sshlogv(const char *file, const char *func, int line, int showfunc,
465     LogLevel level, const char *suffix, const char *fmt, va_list args)
466 {
...
489         do_log(level, forced, suffix, fmt2, args);
------------------------------------------------------------------------
337 do_log(LogLevel level, int force, const char *suffix, const char *fmt,
338     va_list args)
339 {
...
419                 syslog(pri, "%.500s", fmtbuf);
------------------------------------------------------------------------

Our two key questions, then, are: Does the syslog() of this Debian's
glibc (2.36) call async-signal-unsafe functions such as malloc() and
free()? And if yes, does this glibc still take a mandatory lock when
entering the functions of the malloc family?

- Luckily for us attackers, the answer to our first question is yes; if,
  and only if, the syslog() inside the SIGALRM handler is the very first
  call to syslog(), then __localtime64_r() (which is called by syslog())
  calls malloc(304) to allocate a FILE structure (at line 166) and calls
  malloc(4096) to allocate an internal read buffer (at line 186):

------------------------------------------------------------------------
 28 __localtime64_r (const __time64_t *t, struct tm *tp)
 29 {
 30   return __tz_convert (*t, 1, tp);
------------------------------------------------------------------------
567 __tz_convert (__time64_t timer, int use_localtime, struct tm *tp)
568 {
...
577   tzset_internal (tp == &_tmbuf && use_localtime);
------------------------------------------------------------------------
367 tzset_internal (int always)
368 {
...
405   __tzfile_read (tz, 0, NULL);
------------------------------------------------------------------------
105 __tzfile_read (const char *file, size_t extra, char **extrap)
106 {
...
109   FILE *f;
...
166   f = fopen (file, "rce");
...
186   if (__builtin_expect (__fread_unlocked ((void *) &tzhead, sizeof (tzhead),
187                                           1, f) != 1, 0)
------------------------------------------------------------------------

  Note: because we do not control anything about these malloc()ations
  (not their order, not their sizes, not their contents), we took the
  "rce" at line 166 as a much-needed good omen.

- And luckily for us, the answer to our second question is no; since
  October 2017, the glibc's malloc functions do not take any lock
  anymore, when single-threaded (like sshd):

  https://sourceware.org/git?p=glibc.git;a=commit;h=a15d53e2de4c7d83bda251469d92a3c7b49a90db
  https://sourceware.org/git?p=glibc.git;a=commit;h=3f6bb8a32e5f5efd78ac08c41e623651cc242a89
  https://sourceware.org/git?p=glibc.git;a=commit;h=905a7725e9157ea522d8ab97b4c8b96aeb23df54

Moreover, this Debian version suffers from the ASLR weakness described
in the following great blog posts (by Justin Miller and Mathias Krause,
respectively):

  https://zolutal.github.io/aslrnt/
  https://grsecurity.net/toolchain_necromancy_past_mistakes_haunting_aslr

Concretely, in the case of sshd on i386, every memory mapping is
randomized normally (sshd's PIE, the heap, most libraries, the stack),
but the glibc itself is always mapped either at address 0xb7200000 or at
address 0xb7400000; in other words, we can correctly guess the glibc's
address half of the time (a small price to pay for defeating ASLR). In
our exploit we assume that the glibc is mapped at address 0xb7400000,
because it is slightly more common than 0xb7200000.

Our next question is: which code paths inside the glibc's malloc
functions, if interrupted by SIGALRM at the right time, leave the heap
in an inconsistent state, exploitable during one of the malloc() calls
inside the SIGALRM handler?

We found several interesting (and surprising!) code paths, but the one
we chose involves only relative sizes, not absolute addresses (unlike
various code paths inside unlink_chunk(), for example); this difference
might prove crucial for a future amd64 exploit. This code path, inside
malloc(), splits a large free chunk (victim) into two smaller chunks;
the first chunk is returned to malloc()'s caller (at line 4345) and the
second chunk (remainder) is linked into an unsorted list of free chunks
(at lines 4324-4327):

------------------------------------------------------------------------
1449 #define set_head(p, s)       ((p)->mchunk_size = (s))
------------------------------------------------------------------------
3765 _int_malloc (mstate av, size_t bytes)
3766 {
....
3798   nb = checked_request2size (bytes);
....
4295               size = chunksize (victim);
....
4300               remainder_size = size - nb;
....
4316                   remainder = chunk_at_offset (victim, nb);
....
4320                   bck = unsorted_chunks (av);
4321                   fwd = bck->fd;
....
4324                   remainder->bk = bck;
4325                   remainder->fd = fwd;
4326                   bck->fd = remainder;
4327                   fwd->bk = remainder;
....
4337                   set_head (victim, nb | PREV_INUSE |
4338                             (av != &main_arena ? NON_MAIN_ARENA : 0));
4339                   set_head (remainder, remainder_size | PREV_INUSE);
....
4343               void *p = chunk2mem (victim);
....
4345               return p;
------------------------------------------------------------------------

- If this code path is interrupted by SIGALRM *after* line 4327 but
  *before* line 4339, then the remainder chunk of this split is already
  linked into the unsorted list of free chunks (lines 4324-4327), but
  its size field (mchunk_size) is not yet initialized (line 4339).

- If we are able to control its size field (through leftovers from
  previous heap allocations), then we can make this remainder chunk
  larger and overlap with other heap chunks, and therefore corrupt heap
  memory when this enlarged, overlapping remainder chunk is eventually
  malloc()ated and written to (inside the SIGALRM handler).

Our last question, then, is: given that we do not control anything about
the malloc() calls inside the SIGALRM handler, what can we overwrite in
the heap to achieve arbitrary code execution before sshd calls _exit()
(in sshsigdie())?

Because __tzfile_read() (inside the SIGALRM handler) malloc()ates a FILE
structure in the heap (at line 166 above), and because FILE structures
have a long history of abuse for arbitrary code execution, we decided to
aim our heap corruption at this FILE structure. This is, however, easier
said than done: our heap corruption is very limited, and FILE structures
have been significantly hardened over the years (by IO_validate_vtable()
and PTR_DEMANGLE(), for example).

Eventually, we devised the following technique (which seems to be
specific to the i386 glibc -- the amd64 glibc does not seem to use
_vtable_offset at all):

- with our limited heap corruption, we overwrite the _vtable_offset
  field (a single signed char) of __tzfile_read()'s FILE structure;

- the glibc's libio functions will therefore look for this FILE
  structure's vtable pointer (a pointer to an array of function
  pointers) at a non-zero offset (our overwritten _vtable_offset),
  instead of the default zero offset;

- we (attackers) can easily control this fake vtable pointer (through
  leftovers from previous heap allocations), because the FILE structure
  around this offset is not explicitly initialized by fopen();

- to pass the glibc's security checks, our fake vtable pointer must
  point somewhere into the __libc_IO_vtables section: we decided to
  point it to the vtable for wide-character streams, _IO_wfile_jumps
  (i.e., to 0xb761b740, since we assume that the glibc is mapped at
  address 0xb7400000);

- as a result, __fread_unlocked() (at line 186 above) calls
  _IO_wfile_underflow() (instead of _IO_file_underflow()), which calls a
  function pointer (__fct) that basically comes from a structure whose
  pointer (_codecvt) is yet another field of the FILE structure;

- we (attackers) can easily control this _codecvt pointer (through
  leftovers from previous heap allocations, because this field of the
  FILE structure is not explicitly initialized by fopen()), which also
  allows us to control the __fct function pointer.

In summary, by overwriting a single byte (_vtable_offset) of the FILE
structure malloc()ated by fopen(), we can call our own __fct function
pointer and execute arbitrary code during __fread_unlocked().

------------------------------------------------------------------------
Practice
------------------------------------------------------------------------

    I wanted it perfect, no wrinkles in it
        -- The Interrupters, "In the Mirror"

To mount this attack against sshd's privileged child, let us first
imagine the following heap layout (the "XXX"s are "barrier" chunks that
allow us to make holes in the heap; for example, small memory-leaked
chunks):

---|----------------------------------------------|---|------------|---
XXX|                  large hole                  |XXX| small hole |XXX
---|----------------------------------------------|---|------------|---
   |                     ~8KB                     |   |    320B    |

- shortly before sshd receives the SIGALRM, we malloc()ate a ~4KB chunk
  that splits the large ~8KB hole into two smaller chunks:

---|-----------------------|----------------------|---|------------|---
XXX| large allocated chunk | free remainder chunk |XXX| small hole |XXX
---|-----------------------|----------------------|---|------------|---
   |         ~4KB          |         ~4KB         |   |    320B    |

- but if this malloc() is interrupted by SIGALRM *after* line 4327 but
  *before* line 4339, then the remainder chunk of this split is already
  linked into the unsorted list of free chunks, but its size field is
  under our control (through leftovers from previous heap allocations),
  and this artificially enlarged remainder chunk overlaps with the
  following small hole:

---|-----------------------|----------------------|---|------------|---
XXX| large allocated chunk | real remainder chunk |XXX| small hole |XXX
---|-----------------------|----------------------|---|------------|---
   |         ~4KB          |<------------------------------------->|
                             artificially enlarged remainder chunk

- when the SIGALRM handler calls syslog() and hence __tzfile_read(),
  fopen() malloc()ates the small hole for its FILE structure, and
  __fread_unlocked() malloc()ates a 4KB read buffer, thereby splitting
  the enlarged remainder chunk in two (the 4KB read buffer and a small
  remainder chunk):

---|-----------------------|----------------------|---|------------|---
XXX| large allocated chunk |                      |XXX|    FILE    |XXX
---|-----------------------|----------------------|---|--|---------|---
   |         ~4KB          |<--------------------------->|<------->|
                                   4KB read buffer        remainder

- we therefore overwrite parts of the FILE structure with the internal
  header of this small remainder chunk: more precisely, we overwrite the
  FILE's _vtable_offset with the third byte of this header's bk field,
  which is a pointer to the unsorted list of free chunks, 0xb761d7f8
  (i.e., we overwrite _vtable_offset with 0x61);

- then, as explained in the "Theory" subsection, __fread_unlocked()
  calls _IO_wfile_underflow() (instead of _IO_file_underflow()), which
  calls our own __fct function pointer (through our own _codecvt
  pointer) and executes our arbitrary code.

  Note: we have not yet explained how to reliably go from a controlled
  _codecvt pointer to a controlled __fct function pointer; we will do
  so, but we must first solve a more pressing problem.

Indeed, we learned from our work on older OpenSSH versions that we will
never win this signal handler race condition if our large race window
contains only one small race window. Consequently, we implemented the
following strategy, based on the following heap layout:

---|------------|---|------------|---|------------|---|------------|---
XXX|large hole 1|XXX|small hole 1|XXX|large hole 2|XXX|small hole 2|...
---|------------|---|------------|---|------------|---|------------|---
   |    ~8KB    |   |    320B    |   |    ~8KB    |   |    320B    |

The last packet that we send to sshd (shortly before the delivery of
SIGALRM) forces sshd to perform the following sequence of malloc()
calls: malloc(~4KB), malloc(304), malloc(~4KB), malloc(304), etc.

1/ Our first malloc(~4KB) splits the large hole 1 in two:

- if this first split is interrupted by SIGALRM at the right time, then
  the fopen() inside the SIGALRM handler malloc()ates the small hole 1
  for its FILE structure, and we achieve arbitrary code execution as
  explained above;

- if not, then we malloc()ate the small hole 1 ourselves with our first
  malloc(304), and:

2/ Our second malloc(~4KB) splits the large hole 2 in two:

- if this second split is interrupted by SIGALRM at the right time, then
  the fopen() inside the SIGALRM handler malloc()ates the small hole 2
  for its FILE structure, and we achieve arbitrary code execution as
  explained above;

- if not, then we malloc()ate the small hole 2 ourselves with our second
  malloc(304), etc.

We were able to make 27 pairs of such large and small holes in sshd's
heap (28 would exceed PACKET_MAX_SIZE, 256KB): our large race window now
contains 27 small race windows! Achieving this complex heap layout was
extremely painful and time-consuming, but the two highlights are:

- We abuse sshd's public-key parsing code to perform arbitrary sequences
  of malloc() and free() calls (at lines 1805 and 573):

------------------------------------------------------------------------
1754 cert_parse(struct sshbuf *b, struct sshkey *key, struct sshbuf *certbuf)
1755 {
....
1797         while (sshbuf_len(principals) > 0) {
....
1805                 if ((ret = sshbuf_get_cstring(principals, &principal,
....
1820                 key->cert->principals[key->cert->nprincipals++] = principal;
1821         }
------------------------------------------------------------------------
 562 cert_free(struct sshkey_cert *cert)
 563 {
 ...
 572         for (i = 0; i < cert->nprincipals; i++)
 573                 free(cert->principals[i]);
------------------------------------------------------------------------

- We were unable to find a memory leak for our small "barrier" chunks;
  instead, we use tcache chunks (which are never really freed, because
  their inuse bit is never cleared) as makeshift "barrier" chunks.

To reliably achieve this heap layout, we send five different public-key
packets to sshd (packets a/ to d/ can be sent long before SIGALRM; most
of packet e/ can also be sent long before SIGALRM, but its very last
byte must be sent at the very last moment):

a/ We malloc()ate and free() a variety of tcache chunks, to ensure that
the heap allocations that we do not control end up in these tcache
chunks and do not interfere with our careful heap layout.

b/ We malloc()ate and free() chunks of various sizes, to make our 27
pairs of large and small holes (and the corresponding "barrier" chunks).

c/ We malloc()ate and free() ~4KB chunks and 320B chunks, to:

- write the fake header (the large size field) of our potentially
  enlarged remainder chunk, into the middle of our large holes;

- write the fake footer of our potentially enlarged remainder chunk, to
  the end of our small holes (to pass the glibc's security checks);

- write our fake vtable and _codecvt pointers, into our small holes
  (which are potential FILE structures).

d/ We malloc()ate and free() one very large string (nearly 256KB), to
ensure that our large and small holes are removed from the unsorted list
of free chunks and placed into their respective malloc bins.

e/ We force sshd to perform our final sequence of malloc() calls
(malloc(~4KB), malloc(304), malloc(~4KB), malloc(304), etc), to open our
27 small race windows.

Attentive readers may have noticed that we have still not addressed
(literally and figuratively) the problem of _codecvt. In fact, _codecvt
is a pointer to a structure (_IO_codecvt) that contains a pointer to a
structure (__gconv_step) that contains the __fct function pointer that
allows us to execute arbitrary code. To reliably control __fct through
_codecvt, we simply point _codecvt to one of the glibc's malloc bins,
which conveniently contains a pointer to one of our free chunks in the
heap, which contains our own __fct function pointer to arbitrary glibc
code (all of these glibc addresses are known to us, because we assume
that the glibc is mapped at address 0xb7400000).

------------------------------------------------------------------------
Timing
------------------------------------------------------------------------

    We're running out of time
        -- The Interrupters, "As We Live"

As we implemented this third exploit, it became clear that we could not
simply re-use the timing strategy that we had used against the two older
OpenSSH versions: we were never winning this new race condition.
Eventually, we understood why:

- It takes a long time (~10ms) for sshd to parse our fifth and last
  public key (packet e/ above); in other words, our large race window is
  too large (our 27 small race windows are like needles in a haystack).

- The user_specific_delay() that was introduced recently (OpenSSH 7.8p1)
  delays sshd's response to our last public-key packet by up to ~9ms and
  therefore destroys our feedback-based timing strategy.

As a result, we developed a completely different timing strategy:

- from time to time, we send our last public-key packet with a little
  mistake that produces an error response (lines 138-142 below), right
  before the call to sshkey_from_blob() that parses our public key;

- from time to time, we send our last public-key packet with another
  little mistake that produces an error response (lines 151-155 below),
  right after the call to sshkey_from_blob() that parses our public key;

- the difference between these two response times is the time that it
  takes for sshd to parse our last public key, and this allows us to
  precisely time the transmission of our last packets (to ensure that
  sshd has the time to parse our public key in the unprivileged child,
  send it to the privileged child, and start to parse it there, before
  the delivery of SIGALRM).

------------------------------------------------------------------------
 88 userauth_pubkey(struct ssh *ssh, const char *method)
 89 {
...
138         if (pktype == KEY_UNSPEC) {
139                 /* this is perfectly legal */
140                 verbose_f("unsupported public key algorithm: %s", pkalg);
141                 goto done;
142         }
143         if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
144                 error_fr(r, "parse key");
145                 goto done;
146         }
...
151         if (key->type != pktype) {
152                 error_f("type mismatch for decoded key "
153                     "(received %d, expected %d)", key->type, pktype);
154                 goto done;
155         }
------------------------------------------------------------------------

With this change in strategy, it takes ~10,000 tries on average to win
the race condition; i.e., with 100 connections (MaxStartups) accepted
per 120 seconds (LoginGraceTime), it takes ~3-4 hours on average to win
the race condition, and ~6-8 hours to obtain a remote root shell
(because of ASLR).


========================================================================
Towards an amd64 exploit
========================================================================

    What's your plan for tomorrow?
        -- The Interrupters, "Take Back the Power"

We decided to target Rocky Linux 9 (a Red Hat Enterprise Linux 9
derivative), from "Rocky-9.4-x86_64-minimal.iso", for two reasons:

- its OpenSSH version (8.7p1) is vulnerable to this signal handler race
  condition and its glibc is always mapped at a multiple of 2MB (because
  of the ASLR weakness discussed in the previous "Theory" subsection),
  which makes partial pointer overwrites much more powerful;

- the syslog() function (which is async-signal-unsafe but is called by
  sshd's SIGALRM handler) of this glibc version (2.34) internally calls
  __open_memstream(), which malloc()ates a FILE structure in the heap,
  and also calls calloc(), realloc(), and free() (which gives us some
  much-needed freedom).

With a heap corruption as a primitive, two FILE structures malloc()ated
in the heap, and 21 fixed bits in the glibc's addresses, we believe that
this signal handler race condition is exploitable on amd64 (probably not
in ~6-8 hours, but hopefully in less than a week). Only time will tell.

Side note: we discovered that Ubuntu 24.04 does not re-randomize the
ASLR of its sshd children (it is randomized only once, at boot time); we
tracked this down to the patch below, which turns off sshd's rexec_flag.
This is generally a bad idea, but in the particular case of this signal
handler race condition, it prevents sshd from being exploitable: the
syslog() inside the SIGALRM handler does not call any of the malloc
functions, because it is never the very first call to syslog().

  https://git.launchpad.net/ubuntu/+source/openssh/tree/debian/patches/systemd-socket-activation.patch


========================================================================
Patches and mitigation
========================================================================

    The storm has come and gone
        -- The Interrupters, "Good Things"

On June 6, 2024, this signal handler race condition was fixed by commit
81c1099 ("Add a facility to sshd(8) to penalise particular problematic
client behaviours"), which moved the async-signal-unsafe code from
sshd's SIGALRM handler to sshd's listener process, where it can be
handled synchronously:

  https://github.com/openssh/openssh-portable/commit/81c1099d22b81ebfd20a334ce986c4f753b0db29

Because this fix is part of a large commit (81c1099), on top of an even
larger defense-in-depth commit (03e3de4, "Start the process of splitting
sshd into separate binaries"), it might prove difficult to backport. In
that case, the signal handler race condition itself can be fixed by
removing or commenting out the async-signal-unsafe code from the
sshsigdie() function; for example:

------------------------------------------------------------------------
sshsigdie(const char *file, const char *func, int line, int showfunc,
    LogLevel level, const char *suffix, const char *fmt, ...)
{
#if 0
        va_list args;

        va_start(args, fmt);
        sshlogv(file, func, line, showfunc, SYSLOG_LEVEL_FATAL,
            suffix, fmt, args);
        va_end(args);
#endif
        _exit(1);
}
------------------------------------------------------------------------

Finally, if sshd cannot be updated or recompiled, this signal handler
race condition can be fixed by simply setting LoginGraceTime to 0 in the
configuration file. This makes sshd vulnerable to a denial of service
(the exhaustion of all MaxStartups connections), but it makes it safe
from the remote code execution presented in this advisory.


========================================================================
Acknowledgments
========================================================================

We thank OpenSSH's developers for their outstanding work and close
collaboration on this release. We also thank the distros@openwall.
Finally, we dedicate this advisory to Sophia d'Antoine.


========================================================================
Timeline
========================================================================

2024-05-19: We contacted OpenSSH's developers. Successive iterations of
patches and patch reviews followed.

2024-06-20: We contacted the distros@openwall.

2024-07-01: Coordinated Release Date.
